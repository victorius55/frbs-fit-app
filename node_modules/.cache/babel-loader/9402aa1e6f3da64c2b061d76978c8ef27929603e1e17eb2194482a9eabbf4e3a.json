{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport { i as isFirestoreDataReference, a as isFirestoreQuery, b as isDatabaseReference, c as isStorageReference, n as noop, u as useFirebaseApp, d as isObject, e as checkWrittenTarget, f as useIsSSR, g as isPOJO, h as isDocumentRef, w as walkGet, j as callOnceWithArg, k as walkSet, l as getGlobalScope, s as setupOnAuthStateChanged, m as authUserMap, o as isClient, _ as _FirebaseAppInjectionKey } from './shared/vuefire.0feb90cc.mjs';\nexport { V as VueFireAppCheck, r as getCurrentUser, t as updateCurrentUserProfile, x as useAppCheck, v as useAppCheckToken, p as useCurrentUser, q as useIsCurrentUserLoaded } from './shared/vuefire.0feb90cc.mjs';\nimport { toValue, ref, shallowRef, getCurrentScope, isRef, watch, onScopeDispose, getCurrentInstance, onServerPrefetch, isVue3, toRef, effectScope, inject, computed } from 'vue-demi';\nimport { get, onValue, onChildAdded, onChildRemoved, onChildChanged, onChildMoved, getDatabase } from 'firebase/database';\nimport { Timestamp, GeoPoint, getDocs, onSnapshot, getDoc, getFirestore } from 'firebase/firestore';\nimport { initializeAuth, browserPopupRedirectResolver, indexedDBLocalPersistence, browserLocalPersistence, browserSessionPersistence } from 'firebase/auth';\nimport { getStorage, getDownloadURL, getMetadata, updateMetadata, uploadBytesResumable } from 'firebase/storage';\nimport 'firebase/app-check';\nimport 'firebase/app';\nconst _initialStatesMap = /* @__PURE__ */new WeakMap();\nfunction useSSRInitialState(initialState, firebaseApp) {\n  if (!_initialStatesMap.has(firebaseApp)) {\n    _initialStatesMap.set(firebaseApp, initialState || {\n      f: {},\n      r: {},\n      s: {},\n      u: {}\n    });\n  }\n  return _initialStatesMap.get(firebaseApp);\n}\nfunction getInitialValue(dataSource, ssrKey, fallbackValue, firebaseApp) {\n  if (!dataSource) return fallbackValue;\n  const [sourceType, path] = getDataSourceInfo(dataSource);\n  if (!sourceType) return fallbackValue;\n  const initialState = useSSRInitialState(void 0, firebaseApp)[sourceType] || {};\n  const key = ssrKey || path;\n  return key && key in initialState ? initialState[key] : fallbackValue;\n}\nfunction deferInitialValueSetup(dataSource, ssrKey, promise, firebaseApp) {\n  if (!dataSource) return;\n  const [sourceType, path] = getDataSourceInfo(dataSource);\n  if (!sourceType) return;\n  const initialState = useSSRInitialState(void 0, firebaseApp)[sourceType];\n  const key = ssrKey || path;\n  if (key) {\n    promise.then(value => {\n      initialState[key] = value;\n    }).catch(noop);\n    return key;\n  }\n}\nfunction getDataSourceInfo(dataSource) {\n  return isFirestoreDataReference(dataSource) || isFirestoreQuery(dataSource) ? [\"f\", dataSource.path] : isDatabaseReference(dataSource) ? [\"r\", dataSource.toString()] : isStorageReference(dataSource) ? [\"s\", dataSource.toString()] : [];\n}\nconst appPendingPromises = /* @__PURE__ */new WeakMap();\nfunction addPendingPromise(promise, dataSource, ssrKey) {\n  const app = useFirebaseApp();\n  if (!appPendingPromises.has(app)) {\n    appPendingPromises.set(app, /* @__PURE__ */new Map());\n  }\n  const pendingPromises = appPendingPromises.get(app);\n  const key = deferInitialValueSetup(dataSource, ssrKey, promise, app);\n  if (key) {\n    pendingPromises.set(key, promise);\n  } else {\n    if (process.env.NODE_ENV !== \"production\") {\n      console.warn(\"[VueFire SSR]: Could not get the path of the data source\");\n    }\n  }\n  return key ? () => pendingPromises.delete(key) : noop;\n}\nfunction usePendingPromises(app) {\n  app = app || useFirebaseApp();\n  const pendingPromises = appPendingPromises.get(app);\n  const p = pendingPromises ? Promise.all(Array.from(pendingPromises).map(([key, promise]) => promise.then(data => [key, data]))) : Promise.resolve([]);\n  appPendingPromises.delete(app);\n  return p;\n}\nfunction createRecordFromDatabaseSnapshot(snapshot) {\n  if (!snapshot.exists()) return null;\n  const value = snapshot.val();\n  return isObject(value) ? Object.defineProperty(value, \"id\", {\n    // allow destructuring without interfering without using the `id` property\n    value: snapshot.key\n  }) : {\n    // if the value is a primitive we can just return a regular object, it's easier to debug\n    // @ts-expect-error: $value doesn't exist\n    $value: value,\n    id: snapshot.key\n  };\n}\nfunction indexForKey(array, key) {\n  for (let i = 0; i < array.length; i++) {\n    if (array[i].id === key) return i;\n  }\n  return -1;\n}\nconst DEFAULT_OPTIONS$1 = {\n  reset: false,\n  serialize: createRecordFromDatabaseSnapshot,\n  wait: true\n};\nfunction bindAsObject(target, document, resolve, reject, extraOptions) {\n  const options = Object.assign({}, DEFAULT_OPTIONS$1, extraOptions);\n  let unsubscribe = noop;\n  function onValueCallback(snapshot) {\n    const value = options.serialize(snapshot);\n    target.value = value;\n    resolve(value);\n  }\n  if (options.once) {\n    get(document).then(onValueCallback).catch(reject);\n  } else {\n    unsubscribe = onValue(document, onValueCallback, reject);\n  }\n  return reset => {\n    unsubscribe();\n    if (reset) {\n      const value = typeof reset === \"function\" ? reset() : null;\n      target.value = value;\n    }\n  };\n}\nfunction bindAsArray(target, collection, resolve, reject, extraOptions) {\n  const options = Object.assign({}, DEFAULT_OPTIONS$1, extraOptions);\n  let arrayRef = options.wait ? [] : target;\n  if (!options.wait) {\n    target.value = [];\n  }\n  let removeChildAddedListener = noop;\n  let removeChildChangedListener = noop;\n  let removeChildRemovedListener = noop;\n  let removeChildMovedListener = noop;\n  let removeValueListener = noop;\n  if (options.once) {\n    get(collection).then(data => {\n      const array = [];\n      data.forEach(snapshot => {\n        array.push(options.serialize(snapshot));\n      });\n      resolve(target.value = array);\n    }).catch(reject);\n  } else {\n    removeChildAddedListener = onChildAdded(collection, (snapshot, prevKey) => {\n      const array = toValue(arrayRef);\n      const index = prevKey ? indexForKey(array, prevKey) + 1 : 0;\n      array.splice(index, 0, options.serialize(snapshot));\n    }, reject);\n    removeChildRemovedListener = onChildRemoved(collection, snapshot => {\n      const array = toValue(arrayRef);\n      array.splice(indexForKey(array, snapshot.key), 1);\n    }, reject);\n    removeChildChangedListener = onChildChanged(collection, snapshot => {\n      const array = toValue(arrayRef);\n      array.splice(indexForKey(array, snapshot.key), 1,\n      // cannot be null because it exists\n      options.serialize(snapshot));\n    }, reject);\n    removeChildMovedListener = onChildMoved(collection, (snapshot, prevKey) => {\n      const array = toValue(arrayRef);\n      const index = indexForKey(array, snapshot.key);\n      const oldRecord = array.splice(index, 1)[0];\n      const newIndex = prevKey ? indexForKey(array, prevKey) + 1 : 0;\n      array.splice(newIndex, 0, oldRecord);\n    }, reject);\n    removeValueListener = onValue(collection, () => {\n      const array = toValue(arrayRef);\n      if (options.wait) {\n        target.value = array;\n        arrayRef = target;\n      }\n      resolve(array);\n      removeValueListener();\n    }, reject);\n  }\n  return reset => {\n    removeValueListener();\n    removeChildAddedListener();\n    removeChildRemovedListener();\n    removeChildChangedListener();\n    removeChildMovedListener();\n    if (reset) {\n      const value = typeof reset === \"function\" ? reset() : [];\n      target.value = value;\n    }\n  };\n}\nfunction _useDatabaseRef(reference, localOptions = {}, isList = false) {\n  let unbind = noop;\n  const options = Object.assign({}, DEFAULT_OPTIONS$1, localOptions);\n  const initialSourceValue = toValue(reference);\n  const data = options.target || ref();\n  if (process.env.NODE_ENV !== \"production\") {\n    if (options.target && checkWrittenTarget(data, \"useDatabaseObject()/useDatabaseList()\")) {\n      return data;\n    }\n  }\n  const isSSR = useIsSSR();\n  if (isSSR) {\n    options.once = true;\n  }\n  const initialValue = getInitialValue(initialSourceValue, options.ssrKey, data.value, useFirebaseApp());\n  data.value = initialValue;\n  const hasInitialValue = isList ? (initialValue || []).length > 0 : initialValue !== void 0;\n  let shouldStartAsPending = !hasInitialValue;\n  const error = ref();\n  const pending = ref(false);\n  const promise = shallowRef();\n  const hasCurrentScope = getCurrentScope();\n  let removePendingPromise = noop;\n  function bindDatabaseRef() {\n    const referenceValue = toValue(reference);\n    const newPromise = new Promise((resolve, reject) => {\n      unbind(options.reset);\n      if (!referenceValue) {\n        unbind = noop;\n        return resolve(null);\n      }\n      pending.value = shouldStartAsPending;\n      shouldStartAsPending = true;\n      if (Array.isArray(data.value)) {\n        unbind = bindAsArray(data, referenceValue, resolve, reject, options);\n      } else {\n        unbind = bindAsObject(data, referenceValue, resolve, reject, options);\n      }\n    }).catch(reason => {\n      if (promise.value === newPromise) {\n        error.value = reason;\n      }\n      throw reason;\n    }).finally(() => {\n      if (promise.value === newPromise) {\n        pending.value = false;\n      }\n    });\n    promise.value = newPromise;\n  }\n  let stopWatcher = noop;\n  if (isRef(reference) || typeof reference === \"function\") {\n    stopWatcher = watch(reference, bindDatabaseRef);\n  }\n  bindDatabaseRef();\n  if (initialSourceValue) {\n    removePendingPromise = addPendingPromise(promise.value, initialSourceValue, options.ssrKey);\n  }\n  if (hasCurrentScope) {\n    onScopeDispose(stop);\n    if (getCurrentInstance()) {\n      onServerPrefetch(() => promise.value);\n    }\n  }\n  function stop(reset = options.reset) {\n    stopWatcher();\n    removePendingPromise();\n    unbind(reset);\n  }\n  return Object.defineProperties(data, {\n    // allow destructuring without interfering with the ref itself\n    data: {\n      get: () => data\n    },\n    error: {\n      get: () => error\n    },\n    pending: {\n      get: () => pending\n    },\n    promise: {\n      get: () => promise\n    },\n    stop: {\n      get: () => stop\n    }\n  });\n}\nfunction useDatabaseList(reference, options) {\n  const data = ref([]);\n  return _useDatabaseRef(reference, {\n    target: data,\n    ...options\n  }, true);\n}\nconst useList = useDatabaseList;\nfunction useDatabaseObject(reference, options) {\n  const data = ref();\n  return _useDatabaseRef(reference, {\n    target: data,\n    ...options\n  });\n}\nconst useObject = useDatabaseObject;\nfunction useDatabase(name) {\n  return getDatabase(useFirebaseApp(name));\n}\nconst firestoreDefaultConverter = {\n  toFirestore(data) {\n    return data;\n  },\n  fromFirestore(snapshot, options) {\n    return snapshot.exists() ? Object.defineProperties(snapshot.data(options), {\n      id: {\n        value: snapshot.id\n      }\n      // TODO: check if worth adding or should be through an option\n      // It could also be an example in the docs about converters\n      // $meta: {\n      //   value: snapshot.metadata,\n      // },\n      // $ref: { get: () => snapshot.ref },\n    }) : null;\n  }\n};\nfunction extractRefs(doc, oldDoc, subs, options) {\n  if (!isPOJO(doc)) return [doc, {}];\n  const dataAndRefs = [{}, {}];\n  const subsByPath = Object.keys(subs).reduce((resultSubs, subKey) => {\n    const sub = subs[subKey];\n    resultSubs[sub.path] = sub.data();\n    return resultSubs;\n  }, {});\n  function recursiveExtract(doc2, oldDoc2, path, result) {\n    oldDoc2 = oldDoc2 || {};\n    const [data, refs] = result;\n    Object.getOwnPropertyNames(doc2).forEach(propertyName => {\n      const descriptor = Object.getOwnPropertyDescriptor(doc2, propertyName);\n      if (descriptor && !descriptor.enumerable) {\n        Object.defineProperty(data, propertyName, descriptor);\n      }\n    });\n    for (const key in doc2) {\n      const ref = doc2[key];\n      if (\n      // primitives\n      ref == null ||\n      // TODO: check and remove\n      // Firestore < 4.13\n      ref instanceof Date || ref instanceof Timestamp || ref instanceof GeoPoint) {\n        data[key] = ref;\n      } else if (isDocumentRef(ref)) {\n        const refSubKey = path + key;\n        data[key] =\n        // if the ref was already bound, keep the same object\n        // otherwise set the path as a string so it can be bound later\n        // https://github.com/vuejs/vuefire/issues/831\n        // https://github.com/vuejs/vuefire/pull/1223\n        refSubKey in subs ? oldDoc2[key] : ref.path;\n        refs[refSubKey] = ref.converter ? ref : ref.withConverter(options.converter);\n      } else if (Array.isArray(ref)) {\n        data[key] = Array(ref.length);\n        for (let i = 0; i < ref.length; i++) {\n          const newRef = ref[i];\n          if (newRef && newRef.path in subsByPath) data[key][i] = subsByPath[newRef.path];\n        }\n        recursiveExtract(ref, oldDoc2[key] || data[key], path + key + \".\", [data[key], refs]);\n      } else if (isObject(ref)) {\n        data[key] = {};\n        recursiveExtract(ref, oldDoc2[key], path + key + \".\", [data[key], refs]);\n      } else {\n        data[key] = ref;\n      }\n    }\n  }\n  recursiveExtract(doc, oldDoc, \"\", dataAndRefs);\n  return dataAndRefs;\n}\nconst devalueCustomStringifiers = {\n  TimeStamp: data => data instanceof Timestamp && data.toJSON(),\n  GeoPoint: data => data instanceof GeoPoint && data.toJSON()\n};\nconst devalueCustomParsers = {\n  TimeStamp: data => new Timestamp(data.seconds, data.nanoseconds),\n  GeoPoint: data => new GeoPoint(data.latitude, data.longitude)\n};\nconst DEFAULT_OPTIONS = {\n  reset: false,\n  wait: true,\n  maxRefDepth: 2,\n  converter: firestoreDefaultConverter,\n  snapshotOptions: {\n    serverTimestamps: \"estimate\"\n  }\n};\nfunction unsubscribeAll(subs) {\n  for (const sub in subs) {\n    subs[sub].unsub();\n  }\n}\nfunction updateDataFromDocumentSnapshot(options, target, path, snapshot, subs, ops, depth, resolve, reject) {\n  const [data, refs] = extractRefs(\n  // Pass snapshot options\n  // @ts-expect-error: FIXME: use better types\n  snapshot.data(options.snapshotOptions), walkGet(target, path), subs, options);\n  ops.set(target, path, data);\n  subscribeToRefs(options, target, path, subs, refs, ops, depth, resolve, reject);\n}\nfunction subscribeToDocument({\n  ref: ref2,\n  target,\n  path,\n  depth,\n  resolve,\n  reject,\n  ops\n}, options) {\n  const subs = /* @__PURE__ */Object.create(null);\n  let unbind = noop;\n  if (options.once) {\n    getDoc(ref2).then(snapshot => {\n      if (snapshot.exists()) {\n        updateDataFromDocumentSnapshot(options, target, path, snapshot, subs, ops, depth, resolve, reject);\n      } else {\n        ops.set(target, path, null);\n        resolve();\n      }\n    }).catch(reject);\n  } else {\n    unbind = onSnapshot(ref2, snapshot => {\n      if (snapshot.exists()) {\n        updateDataFromDocumentSnapshot(options, target, path, snapshot, subs, ops, depth, resolve, reject);\n      } else {\n        ops.set(target, path, null);\n        resolve();\n      }\n    }, reject);\n  }\n  return () => {\n    unbind();\n    unsubscribeAll(subs);\n  };\n}\nfunction subscribeToRefs(options, target, path, subs, refs, ops, depth, resolve, reject) {\n  const refKeys = Object.keys(refs);\n  const missingKeys = Object.keys(subs).filter(refKey => refKeys.indexOf(refKey) < 0);\n  missingKeys.forEach(refKey => {\n    subs[refKey].unsub();\n    delete subs[refKey];\n  });\n  if (!refKeys.length || ++depth > options.maxRefDepth) return resolve(path);\n  let resolvedCount = 0;\n  const totalToResolve = refKeys.length;\n  const validResolves = /* @__PURE__ */Object.create(null);\n  function deepResolve(key) {\n    if (key in validResolves) {\n      if (++resolvedCount >= totalToResolve) resolve(path);\n    }\n  }\n  refKeys.forEach(refKey => {\n    const sub = subs[refKey];\n    const ref2 = refs[refKey];\n    const docPath = `${path}.${refKey}`;\n    validResolves[docPath] = true;\n    if (sub) {\n      if (sub.path !== ref2.path) sub.unsub();else return;\n    }\n    subs[refKey] = {\n      data: () => walkGet(target, docPath),\n      unsub: subscribeToDocument({\n        ref: ref2,\n        target,\n        path: docPath,\n        depth,\n        ops,\n        resolve: deepResolve.bind(null, docPath),\n        reject\n      }, options),\n      path: ref2.path\n    };\n  });\n}\nfunction bindCollection(target, collection, ops, resolve, reject, extraOptions) {\n  const options = Object.assign({}, DEFAULT_OPTIONS, extraOptions);\n  const {\n    snapshotListenOptions,\n    snapshotOptions,\n    wait,\n    once\n  } = options;\n  const key = \"value\";\n  let arrayRef = ref(wait ? [] : target.value);\n  if (!wait) ops.set(target, key, []);\n  const originalResolve = resolve;\n  let isResolved;\n  let stopOnSnapshot = noop;\n  const arraySubs = [];\n  const change = {\n    added: ({\n      newIndex,\n      doc\n    }) => {\n      arraySubs.splice(newIndex, 0, /* @__PURE__ */Object.create(null));\n      const subs = arraySubs[newIndex];\n      const [data, refs] = extractRefs(\n      // @ts-expect-error: FIXME: wrong cast, needs better types\n      doc.data(snapshotOptions), void 0, subs, options);\n      ops.add(toValue(arrayRef), newIndex, data);\n      subscribeToRefs(options, arrayRef, `${key}.${newIndex}`, subs, refs, ops, 0, resolve.bind(null, doc), reject);\n    },\n    modified: ({\n      oldIndex,\n      newIndex,\n      doc\n    }) => {\n      const array = toValue(arrayRef);\n      const subs = arraySubs[oldIndex];\n      const oldData = array[oldIndex];\n      const [data, refs] = extractRefs(\n      // @ts-expect-error: FIXME: Better types\n      doc.data(snapshotOptions), oldData, subs, options);\n      arraySubs.splice(newIndex, 0, subs);\n      ops.remove(array, oldIndex);\n      ops.add(array, newIndex, data);\n      subscribeToRefs(options, arrayRef, `${key}.${newIndex}`, subs, refs, ops, 0, resolve, reject);\n    },\n    removed: ({\n      oldIndex\n    }) => {\n      const array = toValue(arrayRef);\n      ops.remove(array, oldIndex);\n      unsubscribeAll(arraySubs.splice(oldIndex, 1)[0]);\n    }\n  };\n  function onSnapshotCallback(snapshot) {\n    const docChanges = snapshot.docChanges(snapshotListenOptions);\n    if (!isResolved && docChanges.length) {\n      isResolved = true;\n      let count = 0;\n      const expectedItems = docChanges.length;\n      const validDocs = /* @__PURE__ */Object.create(null);\n      for (let i = 0; i < expectedItems; i++) {\n        validDocs[docChanges[i].doc.id] = true;\n      }\n      resolve = data => {\n        if (data && data.id in validDocs) {\n          if (++count >= expectedItems) {\n            if (wait) {\n              ops.set(target, key, toValue(arrayRef));\n              arrayRef = target;\n            }\n            originalResolve(toValue(arrayRef));\n            resolve = noop;\n          }\n        }\n      };\n    }\n    docChanges.forEach(c => {\n      change[c.type](c);\n    });\n    if (!docChanges.length) {\n      if (wait) {\n        ops.set(target, key, toValue(arrayRef));\n        arrayRef = target;\n      }\n      resolve(toValue(arrayRef));\n    }\n  }\n  if (once) {\n    getDocs(collection).then(onSnapshotCallback).catch(reject);\n  } else {\n    stopOnSnapshot = onSnapshot(collection, onSnapshotCallback, reject);\n  }\n  return reset => {\n    stopOnSnapshot();\n    if (reset) {\n      const value = typeof reset === \"function\" ? reset() : [];\n      ops.set(target, key, value);\n    }\n    arraySubs.forEach(unsubscribeAll);\n  };\n}\nfunction bindDocument(target, document, ops, resolve, reject, extraOptions) {\n  const options = Object.assign({}, DEFAULT_OPTIONS, extraOptions);\n  const key = \"value\";\n  const subs = /* @__PURE__ */Object.create(null);\n  resolve = callOnceWithArg(resolve, () => walkGet(target, key));\n  let stopOnSnapshot = noop;\n  function onSnapshotCallback(snapshot) {\n    if (snapshot.exists()) {\n      updateDataFromDocumentSnapshot(options, target, key, snapshot, subs, ops, 0, resolve, reject);\n    } else {\n      ops.set(target, key, null);\n      resolve(null);\n    }\n  }\n  if (options.once) {\n    getDoc(document).then(onSnapshotCallback).catch(reject);\n  } else {\n    stopOnSnapshot = onSnapshot(document, onSnapshotCallback, reject);\n  }\n  return reset => {\n    stopOnSnapshot();\n    if (reset) {\n      const value = typeof reset === \"function\" ? reset() : null;\n      ops.set(target, key, value);\n    }\n    unsubscribeAll(subs);\n  };\n}\nconst NO_INITIAL_VALUE = Symbol();\nfunction _useFirestoreRef(docOrCollectionRef, localOptions) {\n  let unbind = noop;\n  const options = Object.assign({}, DEFAULT_OPTIONS, localOptions);\n  const initialSourceValue = toValue(docOrCollectionRef);\n  const data = options.target || ref();\n  if (process.env.NODE_ENV !== \"production\") {\n    if (options.target && checkWrittenTarget(data, \"useDocument()/useCollection()\")) {\n      return data;\n    }\n  }\n  if (useIsSSR()) {\n    options.once = true;\n  }\n  const initialValue = getInitialValue(initialSourceValue, options.ssrKey, NO_INITIAL_VALUE, useFirebaseApp());\n  const hasInitialValue = initialValue !== NO_INITIAL_VALUE;\n  if (hasInitialValue) {\n    data.value = initialValue;\n  }\n  let shouldStartAsPending = !hasInitialValue;\n  const pending = ref(false);\n  const error = ref();\n  const promise = shallowRef();\n  const hasCurrentScope = getCurrentScope();\n  let removePendingPromise = noop;\n  function bindFirestoreRef() {\n    let docRefValue = toValue(docOrCollectionRef);\n    const newPromise = new Promise((resolve, reject) => {\n      unbind(options.reset);\n      if (!docRefValue) {\n        unbind = noop;\n        return resolve(null);\n      }\n      pending.value = shouldStartAsPending;\n      shouldStartAsPending = true;\n      if (!docRefValue.converter) {\n        docRefValue = docRefValue.withConverter(\n        // @ts-expect-error: seems like a ts error\n        options.converter);\n      }\n      unbind = (isDocumentRef(docRefValue) ? bindDocument : bindCollection)(\n      // @ts-expect-error: cannot type with the ternary\n      data, docRefValue, ops, resolve, reject, options);\n    }).catch(reason => {\n      if (promise.value === newPromise) {\n        error.value = reason;\n      }\n      return Promise.reject(reason);\n    }).finally(() => {\n      if (promise.value === newPromise) {\n        pending.value = false;\n      }\n    });\n    promise.value = newPromise;\n  }\n  let stopWatcher = noop;\n  if (isRef(docOrCollectionRef) || typeof docOrCollectionRef === \"function\") {\n    stopWatcher = watch(docOrCollectionRef, bindFirestoreRef);\n  }\n  bindFirestoreRef();\n  if (initialSourceValue) {\n    removePendingPromise = addPendingPromise(promise.value, initialSourceValue, options.ssrKey);\n  }\n  if (getCurrentInstance()) {\n    onServerPrefetch(() => promise.value);\n  }\n  if (hasCurrentScope) {\n    onScopeDispose(stop);\n  }\n  function stop(reset = options.reset) {\n    stopWatcher();\n    removePendingPromise();\n    unbind(reset);\n  }\n  return Object.defineProperties(data, {\n    error: {\n      get: () => error\n    },\n    data: {\n      get: () => data\n    },\n    pending: {\n      get: () => pending\n    },\n    promise: {\n      get: () => promise\n    },\n    stop: {\n      get: () => stop\n    }\n  });\n}\nconst ops = {\n  set: (target, key, value) => walkSet(target, key, value),\n  add: (array, index, data) => array.splice(index, 0, data),\n  remove: (array, index) => array.splice(index, 1)\n};\nfunction useCollection(collectionRef, options) {\n  return _useFirestoreRef(collectionRef, {\n    target: ref([]),\n    ...options\n  });\n}\nfunction useDocument(documentRef, options) {\n  return _useFirestoreRef(documentRef, options);\n}\nfunction useFirestore(name) {\n  return getFirestore(useFirebaseApp(name));\n}\nconst databaseUnbinds = /* @__PURE__ */new WeakMap();\nfunction internalUnbind$1(key, unbinds, reset) {\n  if (unbinds && unbinds[key]) {\n    unbinds[key](reset);\n    delete unbinds[key];\n  }\n}\nconst databasePluginDefaults = {\n  bindName: \"$databaseBind\",\n  unbindName: \"$databaseUnbind\"\n};\nfunction databasePlugin(app, pluginOptions, firebaseApp) {\n  const globalOptions = Object.assign({}, databasePluginDefaults, pluginOptions);\n  const {\n    bindName,\n    unbindName\n  } = globalOptions;\n  const GlobalTarget = isVue3 ? app.config.globalProperties : app.prototype;\n  GlobalTarget[unbindName] = function databaseUnbind(key, reset) {\n    internalUnbind$1(key, databaseUnbinds.get(this), reset);\n    delete this.$firebaseRefs[key];\n  };\n  GlobalTarget[bindName] = function databaseBind(key, source, userOptions) {\n    const options = Object.assign({}, globalOptions, userOptions);\n    const target = toRef(this.$data, key);\n    if (!databaseUnbinds.has(this)) {\n      databaseUnbinds.set(this, {});\n    }\n    const unbinds = databaseUnbinds.get(this);\n    if (unbinds[key]) {\n      unbinds[key](options.reset);\n    }\n    if (pluginOptions) {\n      if (!pluginOptions.bindName) {\n        GlobalTarget[\"$rtdbBind\"] = GlobalTarget[bindName];\n      }\n      if (!pluginOptions.unbindName) {\n        GlobalTarget[\"$rtdbUnbind\"] = GlobalTarget[unbindName];\n      }\n    }\n    const scope = getGlobalScope(firebaseApp || useFirebaseApp(), app).run(() => effectScope());\n    const {\n      promise,\n      stop: _unbind\n    } = app.runWithContext(() => scope.run(() => _useDatabaseRef(source, {\n      target,\n      ...options\n    })));\n    const unbind = reset => {\n      _unbind(reset);\n      scope.stop();\n    };\n    unbinds[key] = unbind;\n    this.$firebaseRefs[key] = source.ref;\n    return promise.value;\n  };\n  app.mixin({\n    beforeCreate() {\n      this.$firebaseRefs = /* @__PURE__ */Object.create(null);\n    },\n    created() {\n      let bindings = this.$options.firebase;\n      if (typeof bindings === \"function\") {\n        bindings = bindings.call(this);\n      }\n      if (!bindings) return;\n      for (const key in bindings) {\n        this[bindName](\n        // ts\n        key, bindings[key], globalOptions);\n      }\n    },\n    beforeUnmount() {\n      const unbinds = databaseUnbinds.get(this);\n      if (unbinds) {\n        for (const key in unbinds) {\n          unbinds[key]();\n        }\n      }\n      this.$firebaseRefs = null;\n    }\n  });\n}\nfunction VueFireDatabaseOptionsAPI(pluginOptions) {\n  return (firebaseApp, app) => {\n    return databasePlugin(app, pluginOptions, firebaseApp);\n  };\n}\nconst firestoreUnbinds = /* @__PURE__ */new WeakMap();\nfunction internalUnbind(key, unbinds, reset) {\n  if (unbinds && unbinds[key]) {\n    unbinds[key](reset);\n    delete unbinds[key];\n  }\n}\nconst firestorePluginDefaults = {\n  bindName: \"$firestoreBind\",\n  unbindName: \"$firestoreUnbind\"\n};\nconst firestorePlugin = function firestorePlugin2(app, pluginOptions, firebaseApp) {\n  const globalOptions = Object.assign({}, firestorePluginDefaults, pluginOptions);\n  const {\n    bindName,\n    unbindName\n  } = globalOptions;\n  const GlobalTarget = isVue3 ? app.config.globalProperties : app.prototype;\n  GlobalTarget[unbindName] = function firestoreUnbind(key, reset) {\n    internalUnbind(key, firestoreUnbinds.get(this), reset);\n    delete this.$firestoreRefs[key];\n  };\n  GlobalTarget[bindName] = function firestoreBind(key, docOrCollectionRef, userOptions) {\n    const options = Object.assign({}, globalOptions, userOptions);\n    const target = toRef(this.$data, key);\n    if (!firestoreUnbinds.has(this)) {\n      firestoreUnbinds.set(this, {});\n    }\n    const unbinds = firestoreUnbinds.get(this);\n    if (unbinds[key]) {\n      unbinds[key](options.reset);\n    }\n    const scope = getGlobalScope(firebaseApp || useFirebaseApp(), app).run(() => effectScope());\n    const {\n      promise,\n      stop: _unbind\n    } = app.runWithContext(() => scope.run(() => _useFirestoreRef(docOrCollectionRef, {\n      target,\n      ...options\n    })));\n    const unbind = reset => {\n      _unbind(reset);\n      scope.stop();\n    };\n    unbinds[key] = unbind;\n    this.$firestoreRefs[key] =\n    // ts\n    docOrCollectionRef;\n    return promise.value;\n  };\n  app.mixin({\n    beforeCreate() {\n      this.$firestoreRefs = /* @__PURE__ */Object.create(null);\n    },\n    created() {\n      const {\n        firestore\n      } = this.$options;\n      const refs = typeof firestore === \"function\" ? firestore.call(this) : firestore;\n      if (!refs) return;\n      for (const key in refs) {\n        this[bindName](key,\n        // @ts-expect-error: FIXME: there is probably a wrong type in global properties\n        refs[key], globalOptions);\n      }\n    },\n    beforeUnmount() {\n      const unbinds = firestoreUnbinds.get(this);\n      if (unbinds) {\n        for (const subKey in unbinds) {\n          unbinds[subKey]();\n        }\n      }\n      this.$firestoreRefs = null;\n    }\n  });\n};\nfunction VueFireFirestoreOptionsAPI(pluginOptions) {\n  return (firebaseApp, app) => {\n    return firestorePlugin(app, pluginOptions, firebaseApp);\n  };\n}\nfunction VueFireAuth(initialUser) {\n  return VueFireAuthWithDependencies({\n    initialUser,\n    dependencies: {\n      popupRedirectResolver: browserPopupRedirectResolver,\n      persistence: [indexedDBLocalPersistence, browserLocalPersistence, browserSessionPersistence]\n    }\n  });\n}\nconst _VueFireAuthKey = Symbol(\"VueFireAuth\");\nfunction VueFireAuthOptionsFromAuth({\n  auth,\n  initialUser\n}) {\n  return (firebaseApp, app) => {\n    const [user, _auth] = _VueFireAuthInit(firebaseApp, app, initialUser, void 0, auth);\n    setupOnAuthStateChanged(user, _auth);\n  };\n}\nfunction VueFireAuthWithDependencies({\n  dependencies,\n  initialUser\n}) {\n  return (firebaseApp, app) => {\n    const [user, auth] = _VueFireAuthInit(firebaseApp, app, initialUser, dependencies);\n    setupOnAuthStateChanged(user, auth);\n  };\n}\nfunction _VueFireAuthInit(firebaseApp, app, initialUser, dependencies, auth = initializeAuth(firebaseApp, dependencies)) {\n  const user = getGlobalScope(firebaseApp, app).run(() => ref(initialUser));\n  authUserMap.set(firebaseApp, user);\n  app.provide(_VueFireAuthKey, auth);\n  return [user, auth];\n}\nfunction useFirebaseAuth(name) {\n  if (process.env.NODE_ENV !== \"production\" && name != null) {\n    console.warn(`[VueFire] useFirebaseAuth() no longer accepts a name parameter to enable tree shaking. If you have multiple applications, you must use \"getAuth(firebaseApp)\" or \"getAuth(useFirebaseApp(name))\" instead.`);\n  }\n  return isClient ? inject(_VueFireAuthKey) : null;\n}\nfunction useFirebaseStorage(name) {\n  return getStorage(useFirebaseApp(name));\n}\nfunction useStorageFileUrl(storageRef) {\n  const initialSourceValue = toValue(storageRef);\n  const url = ref();\n  url.value = getInitialValue(initialSourceValue, void 0, url.value, useFirebaseApp());\n  const promise = shallowRef(Promise.resolve(null));\n  let removePendingPromise = noop;\n  function refresh() {\n    const storageSource = toValue(storageRef);\n    if (storageSource) {\n      promise.value = getDownloadURL(storageSource).then(downloadUrl => url.value = downloadUrl).catch(() => null);\n    } else {\n      promise.value = Promise.resolve(url.value = null);\n    }\n    return promise.value;\n  }\n  refresh();\n  if (isRef(storageRef) || typeof storageRef === \"function\") {\n    watch(storageRef, refresh);\n  }\n  if (initialSourceValue) {\n    removePendingPromise = addPendingPromise(promise.value, initialSourceValue);\n  }\n  if (getCurrentScope()) {\n    onScopeDispose(removePendingPromise);\n  }\n  if (getCurrentInstance()) {\n    onServerPrefetch(() => promise.value);\n  }\n  return {\n    url,\n    refresh,\n    promise\n  };\n}\nfunction useStorageFileMetadata(storageRef) {\n  const initialSourceValue = toValue(storageRef);\n  const metadata = shallowRef();\n  if (initialSourceValue) {\n    metadata.value = getInitialValue(initialSourceValue,\n    // 'm ' is a prefix to differentiate from urls since both are stored in the same object\n    \"m \" + initialSourceValue.toString(), metadata.value, useFirebaseApp());\n  }\n  const promise = shallowRef(Promise.resolve(null));\n  let removePendingPromise = noop;\n  function refresh() {\n    const storageSource = toValue(storageRef);\n    if (storageSource) {\n      promise.value = getMetadata(storageSource).then(data => metadata.value = data).catch(() => null);\n    } else {\n      promise.value = Promise.resolve(metadata.value = null);\n    }\n    return promise.value;\n  }\n  function update(newMetadata) {\n    const storageSource = toValue(storageRef);\n    if (storageSource) {\n      promise.value = updateMetadata(storageSource, newMetadata).then(newData => {\n        return metadata.value = newData;\n      });\n    } else if (process.env.NODE_ENV !== \"production\") {\n      console.warn('[VueFire]: \"update()\" called with no storage source.');\n    }\n    return promise.value;\n  }\n  refresh();\n  if (isRef(storageRef)) {\n    watch(storageRef, refresh);\n  }\n  if (initialSourceValue) {\n    removePendingPromise = addPendingPromise(promise.value, initialSourceValue);\n  }\n  if (getCurrentScope()) {\n    onScopeDispose(removePendingPromise);\n  }\n  if (getCurrentInstance()) {\n    onServerPrefetch(() => promise.value);\n  }\n  return {\n    metadata,\n    update,\n    refresh,\n    promise\n  };\n}\nfunction useStorageFile(storageRef) {\n  const {\n    url,\n    refresh: refreshUrl\n  } = useStorageFileUrl(storageRef);\n  const {\n    metadata,\n    update: updateMetadata2,\n    refresh: refreshMetadata\n  } = useStorageFileMetadata(storageRef);\n  const uploadTask = shallowRef();\n  const snapshot = shallowRef();\n  const uploadError = shallowRef();\n  const uploadProgress = computed(() => {\n    const snap = toValue(snapshot);\n    return snap ? snap.bytesTransferred / snap.totalBytes : null;\n  });\n  let unsub = noop;\n  function upload(newData, newMetadata) {\n    const storageSource = toValue(storageRef);\n    const currentTask = toValue(uploadTask);\n    if (currentTask) {\n      currentTask.cancel();\n    }\n    uploadError.value = null;\n    snapshot.value = null;\n    uploadTask.value = null;\n    url.value = null;\n    metadata.value = null;\n    unsub();\n    if (storageSource) {\n      const newTask = uploadBytesResumable(storageSource, newData, newMetadata);\n      uploadTask.value = newTask;\n      snapshot.value = newTask.snapshot;\n      unsub = newTask.on(\"state_changed\", newSnapshot => {\n        snapshot.value = newSnapshot;\n      });\n      return newTask.then(finalSnapshot => {\n        metadata.value = finalSnapshot.metadata;\n        refreshUrl();\n      }).catch(err => {\n        uploadError.value = err;\n        return Promise.reject(err);\n      }).finally(() => {\n        unsub();\n        uploadTask.value = null;\n      });\n    }\n  }\n  function refresh() {\n    return Promise.all([refreshUrl(), refreshMetadata()]);\n  }\n  if (isRef(storageRef) || typeof storageRef === \"function\") {\n    watch(storageRef, storageSource => {\n      if (!storageSource) {\n        if (uploadTask.value) {\n          unsub();\n          uploadTask.value.cancel();\n        }\n        uploadTask.value = null;\n        snapshot.value = null;\n      }\n      refresh();\n    });\n  }\n  if (getCurrentScope()) {\n    onScopeDispose(unsub);\n  }\n  return {\n    url,\n    metadata,\n    snapshot,\n    uploadTask,\n    uploadError,\n    uploadProgress,\n    upload,\n    updateMetadata: updateMetadata2,\n    refresh\n    // promise,\n  };\n}\nconst useStorage = useFirebaseStorage;\nconst useStorageUrl = useStorageFileUrl;\nconst useStorageMetadata = useStorageFileMetadata;\nconst useStorageObject = useStorageFile;\nfunction VueFire(app, {\n  firebaseApp,\n  modules = []\n}) {\n  app.provide(_FirebaseAppInjectionKey, firebaseApp);\n  for (const firebaseModule of modules) {\n    firebaseModule(firebaseApp, app);\n  }\n}\nexport { VueFire, VueFireAuth, VueFireAuthOptionsFromAuth, VueFireAuthWithDependencies, VueFireDatabaseOptionsAPI, VueFireFirestoreOptionsAPI, _VueFireAuthInit, _VueFireAuthKey, createRecordFromDatabaseSnapshot as databaseDefaultSerializer, databasePlugin, devalueCustomParsers, devalueCustomStringifiers, firestoreDefaultConverter, firestorePlugin, DEFAULT_OPTIONS$1 as globalDatabaseOptions, DEFAULT_OPTIONS as globalFirestoreOptions, databasePlugin as rtdbPlugin, useCollection, useDatabase, useDatabaseList, useDatabaseObject, useDocument, useFirebaseApp, useFirebaseAuth, useFirebaseStorage, useFirestore, useList, useObject, usePendingPromises, useSSRInitialState, useStorage, useStorageFile, useStorageFileMetadata, useStorageFileUrl, useStorageMetadata, useStorageObject, useStorageUrl };","map":{"version":3,"names":["i","isFirestoreDataReference","a","isFirestoreQuery","b","isDatabaseReference","c","isStorageReference","n","noop","u","useFirebaseApp","d","isObject","e","checkWrittenTarget","f","useIsSSR","g","isPOJO","h","isDocumentRef","w","walkGet","j","callOnceWithArg","k","walkSet","l","getGlobalScope","s","setupOnAuthStateChanged","m","authUserMap","o","isClient","_","_FirebaseAppInjectionKey","V","VueFireAppCheck","r","getCurrentUser","t","updateCurrentUserProfile","x","useAppCheck","v","useAppCheckToken","p","useCurrentUser","q","useIsCurrentUserLoaded","toValue","ref","shallowRef","getCurrentScope","isRef","watch","onScopeDispose","getCurrentInstance","onServerPrefetch","isVue3","toRef","effectScope","inject","computed","get","onValue","onChildAdded","onChildRemoved","onChildChanged","onChildMoved","getDatabase","Timestamp","GeoPoint","getDocs","onSnapshot","getDoc","getFirestore","initializeAuth","browserPopupRedirectResolver","indexedDBLocalPersistence","browserLocalPersistence","browserSessionPersistence","getStorage","getDownloadURL","getMetadata","updateMetadata","uploadBytesResumable","_initialStatesMap","WeakMap","useSSRInitialState","initialState","firebaseApp","has","set","getInitialValue","dataSource","ssrKey","fallbackValue","sourceType","path","getDataSourceInfo","key","deferInitialValueSetup","promise","then","value","catch","toString","appPendingPromises","addPendingPromise","app","Map","pendingPromises","process","env","NODE_ENV","console","warn","delete","usePendingPromises","Promise","all","Array","from","map","data","resolve","createRecordFromDatabaseSnapshot","snapshot","exists","val","Object","defineProperty","$value","id","indexForKey","array","length","DEFAULT_OPTIONS$1","reset","serialize","wait","bindAsObject","target","document","reject","extraOptions","options","assign","unsubscribe","onValueCallback","once","bindAsArray","collection","arrayRef","removeChildAddedListener","removeChildChangedListener","removeChildRemovedListener","removeChildMovedListener","removeValueListener","forEach","push","prevKey","index","splice","oldRecord","newIndex","_useDatabaseRef","reference","localOptions","isList","unbind","initialSourceValue","isSSR","initialValue","hasInitialValue","shouldStartAsPending","error","pending","hasCurrentScope","removePendingPromise","bindDatabaseRef","referenceValue","newPromise","isArray","reason","finally","stopWatcher","stop","defineProperties","useDatabaseList","useList","useDatabaseObject","useObject","useDatabase","name","firestoreDefaultConverter","toFirestore","fromFirestore","extractRefs","doc","oldDoc","subs","dataAndRefs","subsByPath","keys","reduce","resultSubs","subKey","sub","recursiveExtract","doc2","oldDoc2","result","refs","getOwnPropertyNames","propertyName","descriptor","getOwnPropertyDescriptor","enumerable","Date","refSubKey","converter","withConverter","newRef","devalueCustomStringifiers","TimeStamp","toJSON","devalueCustomParsers","seconds","nanoseconds","latitude","longitude","DEFAULT_OPTIONS","maxRefDepth","snapshotOptions","serverTimestamps","unsubscribeAll","unsub","updateDataFromDocumentSnapshot","ops","depth","subscribeToRefs","subscribeToDocument","ref2","create","refKeys","missingKeys","filter","refKey","indexOf","resolvedCount","totalToResolve","validResolves","deepResolve","docPath","bind","bindCollection","snapshotListenOptions","originalResolve","isResolved","stopOnSnapshot","arraySubs","change","added","add","modified","oldIndex","oldData","remove","removed","onSnapshotCallback","docChanges","count","expectedItems","validDocs","type","bindDocument","NO_INITIAL_VALUE","Symbol","_useFirestoreRef","docOrCollectionRef","bindFirestoreRef","docRefValue","useCollection","collectionRef","useDocument","documentRef","useFirestore","databaseUnbinds","internalUnbind$1","unbinds","databasePluginDefaults","bindName","unbindName","databasePlugin","pluginOptions","globalOptions","GlobalTarget","config","globalProperties","prototype","databaseUnbind","$firebaseRefs","databaseBind","source","userOptions","$data","scope","run","_unbind","runWithContext","mixin","beforeCreate","created","bindings","$options","firebase","call","beforeUnmount","VueFireDatabaseOptionsAPI","firestoreUnbinds","internalUnbind","firestorePluginDefaults","firestorePlugin","firestorePlugin2","firestoreUnbind","$firestoreRefs","firestoreBind","firestore","VueFireFirestoreOptionsAPI","VueFireAuth","initialUser","VueFireAuthWithDependencies","dependencies","popupRedirectResolver","persistence","_VueFireAuthKey","VueFireAuthOptionsFromAuth","auth","user","_auth","_VueFireAuthInit","provide","useFirebaseAuth","useFirebaseStorage","useStorageFileUrl","storageRef","url","refresh","storageSource","downloadUrl","useStorageFileMetadata","metadata","update","newMetadata","newData","useStorageFile","refreshUrl","updateMetadata2","refreshMetadata","uploadTask","uploadError","uploadProgress","snap","bytesTransferred","totalBytes","upload","currentTask","cancel","newTask","on","newSnapshot","finalSnapshot","err","useStorage","useStorageUrl","useStorageMetadata","useStorageObject","VueFire","modules","firebaseModule","databaseDefaultSerializer","globalDatabaseOptions","globalFirestoreOptions","rtdbPlugin"],"sources":["C:/Users/VictoriaVilla/Firebase-Fitness-App/node_modules/vuefire/dist/index.mjs"],"sourcesContent":["import { i as isFirestoreDataReference, a as isFirestoreQuery, b as isDatabaseReference, c as isStorageReference, n as noop, u as useFirebaseApp, d as isObject, e as checkWrittenTarget, f as useIsSSR, g as isPOJO, h as isDocumentRef, w as walkGet, j as callOnceWithArg, k as walkSet, l as getGlobalScope, s as setupOnAuthStateChanged, m as authUserMap, o as isClient, _ as _FirebaseAppInjectionKey } from './shared/vuefire.0feb90cc.mjs';\nexport { V as VueFireAppCheck, r as getCurrentUser, t as updateCurrentUserProfile, x as useAppCheck, v as useAppCheckToken, p as useCurrentUser, q as useIsCurrentUserLoaded } from './shared/vuefire.0feb90cc.mjs';\nimport { toValue, ref, shallowRef, getCurrentScope, isRef, watch, onScopeDispose, getCurrentInstance, onServerPrefetch, isVue3, toRef, effectScope, inject, computed } from 'vue-demi';\nimport { get, onValue, onChildAdded, onChildRemoved, onChildChanged, onChildMoved, getDatabase } from 'firebase/database';\nimport { Timestamp, GeoPoint, getDocs, onSnapshot, getDoc, getFirestore } from 'firebase/firestore';\nimport { initializeAuth, browserPopupRedirectResolver, indexedDBLocalPersistence, browserLocalPersistence, browserSessionPersistence } from 'firebase/auth';\nimport { getStorage, getDownloadURL, getMetadata, updateMetadata, uploadBytesResumable } from 'firebase/storage';\nimport 'firebase/app-check';\nimport 'firebase/app';\n\nconst _initialStatesMap = /* @__PURE__ */ new WeakMap();\nfunction useSSRInitialState(initialState, firebaseApp) {\n  if (!_initialStatesMap.has(firebaseApp)) {\n    _initialStatesMap.set(\n      firebaseApp,\n      initialState || { f: {}, r: {}, s: {}, u: {} }\n    );\n  }\n  return _initialStatesMap.get(firebaseApp);\n}\nfunction getInitialValue(dataSource, ssrKey, fallbackValue, firebaseApp) {\n  if (!dataSource)\n    return fallbackValue;\n  const [sourceType, path] = getDataSourceInfo(dataSource);\n  if (!sourceType)\n    return fallbackValue;\n  const initialState = useSSRInitialState(void 0, firebaseApp)[sourceType] || {};\n  const key = ssrKey || path;\n  return key && key in initialState ? initialState[key] : fallbackValue;\n}\nfunction deferInitialValueSetup(dataSource, ssrKey, promise, firebaseApp) {\n  if (!dataSource)\n    return;\n  const [sourceType, path] = getDataSourceInfo(dataSource);\n  if (!sourceType)\n    return;\n  const initialState = useSSRInitialState(\n    void 0,\n    firebaseApp\n  )[sourceType];\n  const key = ssrKey || path;\n  if (key) {\n    promise.then((value) => {\n      initialState[key] = value;\n    }).catch(noop);\n    return key;\n  }\n}\nfunction getDataSourceInfo(dataSource) {\n  return isFirestoreDataReference(dataSource) || isFirestoreQuery(dataSource) ? [\"f\", dataSource.path] : isDatabaseReference(dataSource) ? [\"r\", dataSource.toString()] : isStorageReference(dataSource) ? [\"s\", dataSource.toString()] : [];\n}\n\nconst appPendingPromises = /* @__PURE__ */ new WeakMap();\nfunction addPendingPromise(promise, dataSource, ssrKey) {\n  const app = useFirebaseApp();\n  if (!appPendingPromises.has(app)) {\n    appPendingPromises.set(app, /* @__PURE__ */ new Map());\n  }\n  const pendingPromises = appPendingPromises.get(app);\n  const key = deferInitialValueSetup(dataSource, ssrKey, promise, app);\n  if (key) {\n    pendingPromises.set(key, promise);\n  } else {\n    if (process.env.NODE_ENV !== \"production\") {\n      console.warn(\"[VueFire SSR]: Could not get the path of the data source\");\n    }\n  }\n  return key ? () => pendingPromises.delete(key) : noop;\n}\nfunction usePendingPromises(app) {\n  app = app || useFirebaseApp();\n  const pendingPromises = appPendingPromises.get(app);\n  const p = pendingPromises ? Promise.all(\n    Array.from(pendingPromises).map(\n      ([key, promise]) => promise.then((data) => [key, data])\n    )\n  ) : Promise.resolve([]);\n  appPendingPromises.delete(app);\n  return p;\n}\n\nfunction createRecordFromDatabaseSnapshot(snapshot) {\n  if (!snapshot.exists())\n    return null;\n  const value = snapshot.val();\n  return isObject(value) ? Object.defineProperty(value, \"id\", {\n    // allow destructuring without interfering without using the `id` property\n    value: snapshot.key\n  }) : {\n    // if the value is a primitive we can just return a regular object, it's easier to debug\n    // @ts-expect-error: $value doesn't exist\n    $value: value,\n    id: snapshot.key\n  };\n}\nfunction indexForKey(array, key) {\n  for (let i = 0; i < array.length; i++) {\n    if (array[i].id === key)\n      return i;\n  }\n  return -1;\n}\n\nconst DEFAULT_OPTIONS$1 = {\n  reset: false,\n  serialize: createRecordFromDatabaseSnapshot,\n  wait: true\n};\nfunction bindAsObject(target, document, resolve, reject, extraOptions) {\n  const options = Object.assign({}, DEFAULT_OPTIONS$1, extraOptions);\n  let unsubscribe = noop;\n  function onValueCallback(snapshot) {\n    const value = options.serialize(snapshot);\n    target.value = value;\n    resolve(value);\n  }\n  if (options.once) {\n    get(document).then(onValueCallback).catch(reject);\n  } else {\n    unsubscribe = onValue(document, onValueCallback, reject);\n  }\n  return (reset) => {\n    unsubscribe();\n    if (reset) {\n      const value = typeof reset === \"function\" ? reset() : null;\n      target.value = value;\n    }\n  };\n}\nfunction bindAsArray(target, collection, resolve, reject, extraOptions) {\n  const options = Object.assign({}, DEFAULT_OPTIONS$1, extraOptions);\n  let arrayRef = options.wait ? [] : target;\n  if (!options.wait) {\n    target.value = [];\n  }\n  let removeChildAddedListener = noop;\n  let removeChildChangedListener = noop;\n  let removeChildRemovedListener = noop;\n  let removeChildMovedListener = noop;\n  let removeValueListener = noop;\n  if (options.once) {\n    get(collection).then((data) => {\n      const array = [];\n      data.forEach((snapshot) => {\n        array.push(options.serialize(snapshot));\n      });\n      resolve(target.value = array);\n    }).catch(reject);\n  } else {\n    removeChildAddedListener = onChildAdded(\n      collection,\n      (snapshot, prevKey) => {\n        const array = toValue(arrayRef);\n        const index = prevKey ? indexForKey(array, prevKey) + 1 : 0;\n        array.splice(index, 0, options.serialize(snapshot));\n      },\n      reject\n    );\n    removeChildRemovedListener = onChildRemoved(\n      collection,\n      (snapshot) => {\n        const array = toValue(arrayRef);\n        array.splice(indexForKey(array, snapshot.key), 1);\n      },\n      reject\n    );\n    removeChildChangedListener = onChildChanged(\n      collection,\n      (snapshot) => {\n        const array = toValue(arrayRef);\n        array.splice(\n          indexForKey(array, snapshot.key),\n          1,\n          // cannot be null because it exists\n          options.serialize(snapshot)\n        );\n      },\n      reject\n    );\n    removeChildMovedListener = onChildMoved(\n      collection,\n      (snapshot, prevKey) => {\n        const array = toValue(arrayRef);\n        const index = indexForKey(array, snapshot.key);\n        const oldRecord = array.splice(index, 1)[0];\n        const newIndex = prevKey ? indexForKey(array, prevKey) + 1 : 0;\n        array.splice(newIndex, 0, oldRecord);\n      },\n      reject\n    );\n    removeValueListener = onValue(\n      collection,\n      () => {\n        const array = toValue(arrayRef);\n        if (options.wait) {\n          target.value = array;\n          arrayRef = target;\n        }\n        resolve(array);\n        removeValueListener();\n      },\n      reject\n    );\n  }\n  return (reset) => {\n    removeValueListener();\n    removeChildAddedListener();\n    removeChildRemovedListener();\n    removeChildChangedListener();\n    removeChildMovedListener();\n    if (reset) {\n      const value = typeof reset === \"function\" ? reset() : [];\n      target.value = value;\n    }\n  };\n}\n\nfunction _useDatabaseRef(reference, localOptions = {}, isList = false) {\n  let unbind = noop;\n  const options = Object.assign({}, DEFAULT_OPTIONS$1, localOptions);\n  const initialSourceValue = toValue(reference);\n  const data = options.target || ref();\n  if (process.env.NODE_ENV !== \"production\") {\n    if (options.target && checkWrittenTarget(data, \"useDatabaseObject()/useDatabaseList()\")) {\n      return data;\n    }\n  }\n  const isSSR = useIsSSR();\n  if (isSSR) {\n    options.once = true;\n  }\n  const initialValue = getInitialValue(\n    initialSourceValue,\n    options.ssrKey,\n    data.value,\n    useFirebaseApp()\n  );\n  data.value = initialValue;\n  const hasInitialValue = isList ? (initialValue || []).length > 0 : initialValue !== void 0;\n  let shouldStartAsPending = !hasInitialValue;\n  const error = ref();\n  const pending = ref(false);\n  const promise = shallowRef();\n  const hasCurrentScope = getCurrentScope();\n  let removePendingPromise = noop;\n  function bindDatabaseRef() {\n    const referenceValue = toValue(reference);\n    const newPromise = new Promise((resolve, reject) => {\n      unbind(options.reset);\n      if (!referenceValue) {\n        unbind = noop;\n        return resolve(null);\n      }\n      pending.value = shouldStartAsPending;\n      shouldStartAsPending = true;\n      if (Array.isArray(data.value)) {\n        unbind = bindAsArray(\n          data,\n          referenceValue,\n          resolve,\n          reject,\n          options\n        );\n      } else {\n        unbind = bindAsObject(data, referenceValue, resolve, reject, options);\n      }\n    }).catch((reason) => {\n      if (promise.value === newPromise) {\n        error.value = reason;\n      }\n      throw reason;\n    }).finally(() => {\n      if (promise.value === newPromise) {\n        pending.value = false;\n      }\n    });\n    promise.value = newPromise;\n  }\n  let stopWatcher = noop;\n  if (isRef(reference) || typeof reference === \"function\") {\n    stopWatcher = watch(reference, bindDatabaseRef);\n  }\n  bindDatabaseRef();\n  if (initialSourceValue) {\n    removePendingPromise = addPendingPromise(\n      promise.value,\n      initialSourceValue,\n      options.ssrKey\n    );\n  }\n  if (hasCurrentScope) {\n    onScopeDispose(stop);\n    if (getCurrentInstance()) {\n      onServerPrefetch(() => promise.value);\n    }\n  }\n  function stop(reset = options.reset) {\n    stopWatcher();\n    removePendingPromise();\n    unbind(reset);\n  }\n  return Object.defineProperties(data, {\n    // allow destructuring without interfering with the ref itself\n    data: { get: () => data },\n    error: { get: () => error },\n    pending: { get: () => pending },\n    promise: { get: () => promise },\n    stop: { get: () => stop }\n  });\n}\n\nfunction useDatabaseList(reference, options) {\n  const data = ref([]);\n  return _useDatabaseRef(\n    reference,\n    {\n      target: data,\n      ...options\n    },\n    true\n  );\n}\nconst useList = useDatabaseList;\nfunction useDatabaseObject(reference, options) {\n  const data = ref();\n  return _useDatabaseRef(reference, {\n    target: data,\n    ...options\n  });\n}\nconst useObject = useDatabaseObject;\nfunction useDatabase(name) {\n  return getDatabase(useFirebaseApp(name));\n}\n\nconst firestoreDefaultConverter = {\n  toFirestore(data) {\n    return data;\n  },\n  fromFirestore(snapshot, options) {\n    return snapshot.exists() ? Object.defineProperties(snapshot.data(options), {\n      id: { value: snapshot.id }\n      // TODO: check if worth adding or should be through an option\n      // It could also be an example in the docs about converters\n      // $meta: {\n      //   value: snapshot.metadata,\n      // },\n      // $ref: { get: () => snapshot.ref },\n    }) : null;\n  }\n};\nfunction extractRefs(doc, oldDoc, subs, options) {\n  if (!isPOJO(doc))\n    return [doc, {}];\n  const dataAndRefs = [\n    {},\n    {}\n  ];\n  const subsByPath = Object.keys(subs).reduce(\n    (resultSubs, subKey) => {\n      const sub = subs[subKey];\n      resultSubs[sub.path] = sub.data();\n      return resultSubs;\n    },\n    {}\n  );\n  function recursiveExtract(doc2, oldDoc2, path, result) {\n    oldDoc2 = oldDoc2 || {};\n    const [data, refs] = result;\n    Object.getOwnPropertyNames(doc2).forEach((propertyName) => {\n      const descriptor = Object.getOwnPropertyDescriptor(doc2, propertyName);\n      if (descriptor && !descriptor.enumerable) {\n        Object.defineProperty(data, propertyName, descriptor);\n      }\n    });\n    for (const key in doc2) {\n      const ref = doc2[key];\n      if (\n        // primitives\n        ref == null || // TODO: check and remove\n        // Firestore < 4.13\n        ref instanceof Date || ref instanceof Timestamp || ref instanceof GeoPoint\n      ) {\n        data[key] = ref;\n      } else if (isDocumentRef(ref)) {\n        const refSubKey = path + key;\n        data[key] = // if the ref was already bound, keep the same object\n        // otherwise set the path as a string so it can be bound later\n        // https://github.com/vuejs/vuefire/issues/831\n        // https://github.com/vuejs/vuefire/pull/1223\n        refSubKey in subs ? oldDoc2[key] : ref.path;\n        refs[refSubKey] = ref.converter ? ref : ref.withConverter(\n          options.converter\n        );\n      } else if (Array.isArray(ref)) {\n        data[key] = Array(ref.length);\n        for (let i = 0; i < ref.length; i++) {\n          const newRef = ref[i];\n          if (newRef && newRef.path in subsByPath)\n            data[key][i] = subsByPath[newRef.path];\n        }\n        recursiveExtract(ref, oldDoc2[key] || data[key], path + key + \".\", [\n          data[key],\n          refs\n        ]);\n      } else if (isObject(ref)) {\n        data[key] = {};\n        recursiveExtract(ref, oldDoc2[key], path + key + \".\", [data[key], refs]);\n      } else {\n        data[key] = ref;\n      }\n    }\n  }\n  recursiveExtract(doc, oldDoc, \"\", dataAndRefs);\n  return dataAndRefs;\n}\nconst devalueCustomStringifiers = {\n  TimeStamp: (data) => data instanceof Timestamp && data.toJSON(),\n  GeoPoint: (data) => data instanceof GeoPoint && data.toJSON()\n};\nconst devalueCustomParsers = {\n  TimeStamp: (data) => new Timestamp(data.seconds, data.nanoseconds),\n  GeoPoint: (data) => new GeoPoint(data.latitude, data.longitude)\n};\n\nconst DEFAULT_OPTIONS = {\n  reset: false,\n  wait: true,\n  maxRefDepth: 2,\n  converter: firestoreDefaultConverter,\n  snapshotOptions: { serverTimestamps: \"estimate\" }\n};\nfunction unsubscribeAll(subs) {\n  for (const sub in subs) {\n    subs[sub].unsub();\n  }\n}\nfunction updateDataFromDocumentSnapshot(options, target, path, snapshot, subs, ops, depth, resolve, reject) {\n  const [data, refs] = extractRefs(\n    // Pass snapshot options\n    // @ts-expect-error: FIXME: use better types\n    snapshot.data(options.snapshotOptions),\n    walkGet(target, path),\n    subs,\n    options\n  );\n  ops.set(target, path, data);\n  subscribeToRefs(\n    options,\n    target,\n    path,\n    subs,\n    refs,\n    ops,\n    depth,\n    resolve,\n    reject\n  );\n}\nfunction subscribeToDocument({\n  ref: ref2,\n  target,\n  path,\n  depth,\n  resolve,\n  reject,\n  ops\n}, options) {\n  const subs = /* @__PURE__ */ Object.create(null);\n  let unbind = noop;\n  if (options.once) {\n    getDoc(ref2).then((snapshot) => {\n      if (snapshot.exists()) {\n        updateDataFromDocumentSnapshot(\n          options,\n          target,\n          path,\n          snapshot,\n          subs,\n          ops,\n          depth,\n          resolve,\n          reject\n        );\n      } else {\n        ops.set(target, path, null);\n        resolve();\n      }\n    }).catch(reject);\n  } else {\n    unbind = onSnapshot(\n      ref2,\n      (snapshot) => {\n        if (snapshot.exists()) {\n          updateDataFromDocumentSnapshot(\n            options,\n            target,\n            path,\n            snapshot,\n            subs,\n            ops,\n            depth,\n            resolve,\n            reject\n          );\n        } else {\n          ops.set(target, path, null);\n          resolve();\n        }\n      },\n      reject\n    );\n  }\n  return () => {\n    unbind();\n    unsubscribeAll(subs);\n  };\n}\nfunction subscribeToRefs(options, target, path, subs, refs, ops, depth, resolve, reject) {\n  const refKeys = Object.keys(refs);\n  const missingKeys = Object.keys(subs).filter(\n    (refKey) => refKeys.indexOf(refKey) < 0\n  );\n  missingKeys.forEach((refKey) => {\n    subs[refKey].unsub();\n    delete subs[refKey];\n  });\n  if (!refKeys.length || ++depth > options.maxRefDepth)\n    return resolve(path);\n  let resolvedCount = 0;\n  const totalToResolve = refKeys.length;\n  const validResolves = /* @__PURE__ */ Object.create(null);\n  function deepResolve(key) {\n    if (key in validResolves) {\n      if (++resolvedCount >= totalToResolve)\n        resolve(path);\n    }\n  }\n  refKeys.forEach((refKey) => {\n    const sub = subs[refKey];\n    const ref2 = refs[refKey];\n    const docPath = `${path}.${refKey}`;\n    validResolves[docPath] = true;\n    if (sub) {\n      if (sub.path !== ref2.path)\n        sub.unsub();\n      else\n        return;\n    }\n    subs[refKey] = {\n      data: () => walkGet(target, docPath),\n      unsub: subscribeToDocument(\n        {\n          ref: ref2,\n          target,\n          path: docPath,\n          depth,\n          ops,\n          resolve: deepResolve.bind(null, docPath),\n          reject\n        },\n        options\n      ),\n      path: ref2.path\n    };\n  });\n}\nfunction bindCollection(target, collection, ops, resolve, reject, extraOptions) {\n  const options = Object.assign({}, DEFAULT_OPTIONS, extraOptions);\n  const { snapshotListenOptions, snapshotOptions, wait, once } = options;\n  const key = \"value\";\n  let arrayRef = ref(wait ? [] : target.value);\n  if (!wait)\n    ops.set(target, key, []);\n  const originalResolve = resolve;\n  let isResolved;\n  let stopOnSnapshot = noop;\n  const arraySubs = [];\n  const change = {\n    added: ({ newIndex, doc }) => {\n      arraySubs.splice(newIndex, 0, /* @__PURE__ */ Object.create(null));\n      const subs = arraySubs[newIndex];\n      const [data, refs] = extractRefs(\n        // @ts-expect-error: FIXME: wrong cast, needs better types\n        doc.data(snapshotOptions),\n        void 0,\n        subs,\n        options\n      );\n      ops.add(toValue(arrayRef), newIndex, data);\n      subscribeToRefs(\n        options,\n        arrayRef,\n        `${key}.${newIndex}`,\n        subs,\n        refs,\n        ops,\n        0,\n        resolve.bind(null, doc),\n        reject\n      );\n    },\n    modified: ({ oldIndex, newIndex, doc }) => {\n      const array = toValue(arrayRef);\n      const subs = arraySubs[oldIndex];\n      const oldData = array[oldIndex];\n      const [data, refs] = extractRefs(\n        // @ts-expect-error: FIXME: Better types\n        doc.data(snapshotOptions),\n        oldData,\n        subs,\n        options\n      );\n      arraySubs.splice(newIndex, 0, subs);\n      ops.remove(array, oldIndex);\n      ops.add(array, newIndex, data);\n      subscribeToRefs(\n        options,\n        arrayRef,\n        `${key}.${newIndex}`,\n        subs,\n        refs,\n        ops,\n        0,\n        resolve,\n        reject\n      );\n    },\n    removed: ({ oldIndex }) => {\n      const array = toValue(arrayRef);\n      ops.remove(array, oldIndex);\n      unsubscribeAll(arraySubs.splice(oldIndex, 1)[0]);\n    }\n  };\n  function onSnapshotCallback(snapshot) {\n    const docChanges = snapshot.docChanges(snapshotListenOptions);\n    if (!isResolved && docChanges.length) {\n      isResolved = true;\n      let count = 0;\n      const expectedItems = docChanges.length;\n      const validDocs = /* @__PURE__ */ Object.create(null);\n      for (let i = 0; i < expectedItems; i++) {\n        validDocs[docChanges[i].doc.id] = true;\n      }\n      resolve = (data) => {\n        if (data && data.id in validDocs) {\n          if (++count >= expectedItems) {\n            if (wait) {\n              ops.set(target, key, toValue(arrayRef));\n              arrayRef = target;\n            }\n            originalResolve(toValue(arrayRef));\n            resolve = noop;\n          }\n        }\n      };\n    }\n    docChanges.forEach((c) => {\n      change[c.type](c);\n    });\n    if (!docChanges.length) {\n      if (wait) {\n        ops.set(target, key, toValue(arrayRef));\n        arrayRef = target;\n      }\n      resolve(toValue(arrayRef));\n    }\n  }\n  if (once) {\n    getDocs(collection).then(onSnapshotCallback).catch(reject);\n  } else {\n    stopOnSnapshot = onSnapshot(collection, onSnapshotCallback, reject);\n  }\n  return (reset) => {\n    stopOnSnapshot();\n    if (reset) {\n      const value = typeof reset === \"function\" ? reset() : [];\n      ops.set(target, key, value);\n    }\n    arraySubs.forEach(unsubscribeAll);\n  };\n}\nfunction bindDocument(target, document, ops, resolve, reject, extraOptions) {\n  const options = Object.assign({}, DEFAULT_OPTIONS, extraOptions);\n  const key = \"value\";\n  const subs = /* @__PURE__ */ Object.create(null);\n  resolve = callOnceWithArg(resolve, () => walkGet(target, key));\n  let stopOnSnapshot = noop;\n  function onSnapshotCallback(snapshot) {\n    if (snapshot.exists()) {\n      updateDataFromDocumentSnapshot(\n        options,\n        target,\n        key,\n        snapshot,\n        subs,\n        ops,\n        0,\n        resolve,\n        reject\n      );\n    } else {\n      ops.set(target, key, null);\n      resolve(null);\n    }\n  }\n  if (options.once) {\n    getDoc(document).then(onSnapshotCallback).catch(reject);\n  } else {\n    stopOnSnapshot = onSnapshot(document, onSnapshotCallback, reject);\n  }\n  return (reset) => {\n    stopOnSnapshot();\n    if (reset) {\n      const value = typeof reset === \"function\" ? reset() : null;\n      ops.set(target, key, value);\n    }\n    unsubscribeAll(subs);\n  };\n}\n\nconst NO_INITIAL_VALUE = Symbol();\nfunction _useFirestoreRef(docOrCollectionRef, localOptions) {\n  let unbind = noop;\n  const options = Object.assign({}, DEFAULT_OPTIONS, localOptions);\n  const initialSourceValue = toValue(docOrCollectionRef);\n  const data = options.target || ref();\n  if (process.env.NODE_ENV !== \"production\") {\n    if (options.target && checkWrittenTarget(data, \"useDocument()/useCollection()\")) {\n      return data;\n    }\n  }\n  if (useIsSSR()) {\n    options.once = true;\n  }\n  const initialValue = getInitialValue(\n    initialSourceValue,\n    options.ssrKey,\n    NO_INITIAL_VALUE,\n    useFirebaseApp()\n  );\n  const hasInitialValue = initialValue !== NO_INITIAL_VALUE;\n  if (hasInitialValue) {\n    data.value = initialValue;\n  }\n  let shouldStartAsPending = !hasInitialValue;\n  const pending = ref(false);\n  const error = ref();\n  const promise = shallowRef();\n  const hasCurrentScope = getCurrentScope();\n  let removePendingPromise = noop;\n  function bindFirestoreRef() {\n    let docRefValue = toValue(docOrCollectionRef);\n    const newPromise = new Promise((resolve, reject) => {\n      unbind(options.reset);\n      if (!docRefValue) {\n        unbind = noop;\n        return resolve(null);\n      }\n      pending.value = shouldStartAsPending;\n      shouldStartAsPending = true;\n      if (!docRefValue.converter) {\n        docRefValue = docRefValue.withConverter(\n          // @ts-expect-error: seems like a ts error\n          options.converter\n        );\n      }\n      unbind = (isDocumentRef(docRefValue) ? bindDocument : bindCollection)(\n        // @ts-expect-error: cannot type with the ternary\n        data,\n        docRefValue,\n        ops,\n        resolve,\n        reject,\n        options\n      );\n    }).catch((reason) => {\n      if (promise.value === newPromise) {\n        error.value = reason;\n      }\n      return Promise.reject(reason);\n    }).finally(() => {\n      if (promise.value === newPromise) {\n        pending.value = false;\n      }\n    });\n    promise.value = newPromise;\n  }\n  let stopWatcher = noop;\n  if (isRef(docOrCollectionRef) || typeof docOrCollectionRef === \"function\") {\n    stopWatcher = watch(docOrCollectionRef, bindFirestoreRef);\n  }\n  bindFirestoreRef();\n  if (initialSourceValue) {\n    removePendingPromise = addPendingPromise(\n      promise.value,\n      initialSourceValue,\n      options.ssrKey\n    );\n  }\n  if (getCurrentInstance()) {\n    onServerPrefetch(() => promise.value);\n  }\n  if (hasCurrentScope) {\n    onScopeDispose(stop);\n  }\n  function stop(reset = options.reset) {\n    stopWatcher();\n    removePendingPromise();\n    unbind(reset);\n  }\n  return Object.defineProperties(data, {\n    error: { get: () => error },\n    data: { get: () => data },\n    pending: { get: () => pending },\n    promise: { get: () => promise },\n    stop: { get: () => stop }\n  });\n}\nconst ops = {\n  set: (target, key, value) => walkSet(target, key, value),\n  add: (array, index, data) => array.splice(index, 0, data),\n  remove: (array, index) => array.splice(index, 1)\n};\n\nfunction useCollection(collectionRef, options) {\n  return _useFirestoreRef(collectionRef, {\n    target: ref([]),\n    ...options\n  });\n}\nfunction useDocument(documentRef, options) {\n  return _useFirestoreRef(documentRef, options);\n}\nfunction useFirestore(name) {\n  return getFirestore(useFirebaseApp(name));\n}\n\nconst databaseUnbinds = /* @__PURE__ */ new WeakMap();\nfunction internalUnbind$1(key, unbinds, reset) {\n  if (unbinds && unbinds[key]) {\n    unbinds[key](reset);\n    delete unbinds[key];\n  }\n}\n\nconst databasePluginDefaults = {\n  bindName: \"$databaseBind\",\n  unbindName: \"$databaseUnbind\"\n};\nfunction databasePlugin(app, pluginOptions, firebaseApp) {\n  const globalOptions = Object.assign({}, databasePluginDefaults, pluginOptions);\n  const { bindName, unbindName } = globalOptions;\n  const GlobalTarget = isVue3 ? app.config.globalProperties : app.prototype;\n  GlobalTarget[unbindName] = function databaseUnbind(key, reset) {\n    internalUnbind$1(key, databaseUnbinds.get(this), reset);\n    delete this.$firebaseRefs[key];\n  };\n  GlobalTarget[bindName] = function databaseBind(key, source, userOptions) {\n    const options = Object.assign({}, globalOptions, userOptions);\n    const target = toRef(this.$data, key);\n    if (!databaseUnbinds.has(this)) {\n      databaseUnbinds.set(this, {});\n    }\n    const unbinds = databaseUnbinds.get(this);\n    if (unbinds[key]) {\n      unbinds[key](options.reset);\n    }\n    if (pluginOptions) {\n      if (!pluginOptions.bindName) {\n        GlobalTarget[\"$rtdbBind\"] = GlobalTarget[bindName];\n      }\n      if (!pluginOptions.unbindName) {\n        GlobalTarget[\"$rtdbUnbind\"] = GlobalTarget[unbindName];\n      }\n    }\n    const scope = getGlobalScope(firebaseApp || useFirebaseApp(), app).run(\n      () => effectScope()\n    );\n    const { promise, stop: _unbind } = app.runWithContext(\n      () => scope.run(() => _useDatabaseRef(source, { target, ...options }))\n    );\n    const unbind = (reset) => {\n      _unbind(reset);\n      scope.stop();\n    };\n    unbinds[key] = unbind;\n    this.$firebaseRefs[key] = source.ref;\n    return promise.value;\n  };\n  app.mixin({\n    beforeCreate() {\n      this.$firebaseRefs = /* @__PURE__ */ Object.create(null);\n    },\n    created() {\n      let bindings = this.$options.firebase;\n      if (typeof bindings === \"function\") {\n        bindings = bindings.call(this);\n      }\n      if (!bindings)\n        return;\n      for (const key in bindings) {\n        this[bindName](\n          // ts\n          key,\n          bindings[key],\n          globalOptions\n        );\n      }\n    },\n    beforeUnmount() {\n      const unbinds = databaseUnbinds.get(this);\n      if (unbinds) {\n        for (const key in unbinds) {\n          unbinds[key]();\n        }\n      }\n      this.$firebaseRefs = null;\n    }\n  });\n}\nfunction VueFireDatabaseOptionsAPI(pluginOptions) {\n  return (firebaseApp, app) => {\n    return databasePlugin(app, pluginOptions, firebaseApp);\n  };\n}\n\nconst firestoreUnbinds = /* @__PURE__ */ new WeakMap();\nfunction internalUnbind(key, unbinds, reset) {\n  if (unbinds && unbinds[key]) {\n    unbinds[key](reset);\n    delete unbinds[key];\n  }\n}\n\nconst firestorePluginDefaults = {\n  bindName: \"$firestoreBind\",\n  unbindName: \"$firestoreUnbind\"\n};\nconst firestorePlugin = function firestorePlugin2(app, pluginOptions, firebaseApp) {\n  const globalOptions = Object.assign(\n    {},\n    firestorePluginDefaults,\n    pluginOptions\n  );\n  const { bindName, unbindName } = globalOptions;\n  const GlobalTarget = isVue3 ? app.config.globalProperties : app.prototype;\n  GlobalTarget[unbindName] = function firestoreUnbind(key, reset) {\n    internalUnbind(key, firestoreUnbinds.get(this), reset);\n    delete this.$firestoreRefs[key];\n  };\n  GlobalTarget[bindName] = function firestoreBind(key, docOrCollectionRef, userOptions) {\n    const options = Object.assign({}, globalOptions, userOptions);\n    const target = toRef(this.$data, key);\n    if (!firestoreUnbinds.has(this)) {\n      firestoreUnbinds.set(this, {});\n    }\n    const unbinds = firestoreUnbinds.get(this);\n    if (unbinds[key]) {\n      unbinds[key](options.reset);\n    }\n    const scope = getGlobalScope(firebaseApp || useFirebaseApp(), app).run(\n      () => effectScope()\n    );\n    const { promise, stop: _unbind } = app.runWithContext(\n      () => scope.run(\n        () => _useFirestoreRef(docOrCollectionRef, {\n          target,\n          ...options\n        })\n      )\n    );\n    const unbind = (reset) => {\n      _unbind(reset);\n      scope.stop();\n    };\n    unbinds[key] = unbind;\n    this.$firestoreRefs[key] = // ts\n    docOrCollectionRef;\n    return promise.value;\n  };\n  app.mixin({\n    beforeCreate() {\n      this.$firestoreRefs = /* @__PURE__ */ Object.create(null);\n    },\n    created() {\n      const { firestore } = this.$options;\n      const refs = typeof firestore === \"function\" ? firestore.call(this) : firestore;\n      if (!refs)\n        return;\n      for (const key in refs) {\n        this[bindName](\n          key,\n          // @ts-expect-error: FIXME: there is probably a wrong type in global properties\n          refs[key],\n          globalOptions\n        );\n      }\n    },\n    beforeUnmount() {\n      const unbinds = firestoreUnbinds.get(this);\n      if (unbinds) {\n        for (const subKey in unbinds) {\n          unbinds[subKey]();\n        }\n      }\n      this.$firestoreRefs = null;\n    }\n  });\n};\nfunction VueFireFirestoreOptionsAPI(pluginOptions) {\n  return (firebaseApp, app) => {\n    return firestorePlugin(app, pluginOptions, firebaseApp);\n  };\n}\n\nfunction VueFireAuth(initialUser) {\n  return VueFireAuthWithDependencies({\n    initialUser,\n    dependencies: {\n      popupRedirectResolver: browserPopupRedirectResolver,\n      persistence: [\n        indexedDBLocalPersistence,\n        browserLocalPersistence,\n        browserSessionPersistence\n      ]\n    }\n  });\n}\nconst _VueFireAuthKey = Symbol(\"VueFireAuth\");\nfunction VueFireAuthOptionsFromAuth({\n  auth,\n  initialUser\n}) {\n  return (firebaseApp, app) => {\n    const [user, _auth] = _VueFireAuthInit(\n      firebaseApp,\n      app,\n      initialUser,\n      void 0,\n      auth\n    );\n    setupOnAuthStateChanged(user, _auth);\n  };\n}\nfunction VueFireAuthWithDependencies({\n  dependencies,\n  initialUser\n}) {\n  return (firebaseApp, app) => {\n    const [user, auth] = _VueFireAuthInit(\n      firebaseApp,\n      app,\n      initialUser,\n      dependencies\n    );\n    setupOnAuthStateChanged(user, auth);\n  };\n}\nfunction _VueFireAuthInit(firebaseApp, app, initialUser, dependencies, auth = initializeAuth(firebaseApp, dependencies)) {\n  const user = getGlobalScope(firebaseApp, app).run(\n    () => ref(initialUser)\n  );\n  authUserMap.set(firebaseApp, user);\n  app.provide(_VueFireAuthKey, auth);\n  return [user, auth];\n}\nfunction useFirebaseAuth(name) {\n  if (process.env.NODE_ENV !== \"production\" && name != null) {\n    console.warn(\n      `[VueFire] useFirebaseAuth() no longer accepts a name parameter to enable tree shaking. If you have multiple applications, you must use \"getAuth(firebaseApp)\" or \"getAuth(useFirebaseApp(name))\" instead.`\n    );\n  }\n  return isClient ? inject(_VueFireAuthKey) : null;\n}\n\nfunction useFirebaseStorage(name) {\n  return getStorage(useFirebaseApp(name));\n}\nfunction useStorageFileUrl(storageRef) {\n  const initialSourceValue = toValue(storageRef);\n  const url = ref();\n  url.value = getInitialValue(\n    initialSourceValue,\n    void 0,\n    url.value,\n    useFirebaseApp()\n  );\n  const promise = shallowRef(Promise.resolve(null));\n  let removePendingPromise = noop;\n  function refresh() {\n    const storageSource = toValue(storageRef);\n    if (storageSource) {\n      promise.value = getDownloadURL(storageSource).then((downloadUrl) => url.value = downloadUrl).catch(() => null);\n    } else {\n      promise.value = Promise.resolve(url.value = null);\n    }\n    return promise.value;\n  }\n  refresh();\n  if (isRef(storageRef) || typeof storageRef === \"function\") {\n    watch(storageRef, refresh);\n  }\n  if (initialSourceValue) {\n    removePendingPromise = addPendingPromise(promise.value, initialSourceValue);\n  }\n  if (getCurrentScope()) {\n    onScopeDispose(removePendingPromise);\n  }\n  if (getCurrentInstance()) {\n    onServerPrefetch(() => promise.value);\n  }\n  return { url, refresh, promise };\n}\nfunction useStorageFileMetadata(storageRef) {\n  const initialSourceValue = toValue(storageRef);\n  const metadata = shallowRef();\n  if (initialSourceValue) {\n    metadata.value = getInitialValue(\n      initialSourceValue,\n      // 'm ' is a prefix to differentiate from urls since both are stored in the same object\n      \"m \" + initialSourceValue.toString(),\n      metadata.value,\n      useFirebaseApp()\n    );\n  }\n  const promise = shallowRef(\n    Promise.resolve(null)\n  );\n  let removePendingPromise = noop;\n  function refresh() {\n    const storageSource = toValue(storageRef);\n    if (storageSource) {\n      promise.value = getMetadata(storageSource).then((data) => metadata.value = data).catch(() => null);\n    } else {\n      promise.value = Promise.resolve(metadata.value = null);\n    }\n    return promise.value;\n  }\n  function update(newMetadata) {\n    const storageSource = toValue(storageRef);\n    if (storageSource) {\n      promise.value = updateMetadata(storageSource, newMetadata).then(\n        (newData) => {\n          return metadata.value = newData;\n        }\n      );\n    } else if (process.env.NODE_ENV !== \"production\") {\n      console.warn('[VueFire]: \"update()\" called with no storage source.');\n    }\n    return promise.value;\n  }\n  refresh();\n  if (isRef(storageRef)) {\n    watch(storageRef, refresh);\n  }\n  if (initialSourceValue) {\n    removePendingPromise = addPendingPromise(promise.value, initialSourceValue);\n  }\n  if (getCurrentScope()) {\n    onScopeDispose(removePendingPromise);\n  }\n  if (getCurrentInstance()) {\n    onServerPrefetch(() => promise.value);\n  }\n  return { metadata, update, refresh, promise };\n}\nfunction useStorageFile(storageRef) {\n  const { url, refresh: refreshUrl } = useStorageFileUrl(storageRef);\n  const {\n    metadata,\n    update: updateMetadata2,\n    refresh: refreshMetadata\n  } = useStorageFileMetadata(storageRef);\n  const uploadTask = shallowRef();\n  const snapshot = shallowRef();\n  const uploadError = shallowRef();\n  const uploadProgress = computed(() => {\n    const snap = toValue(snapshot);\n    return snap ? snap.bytesTransferred / snap.totalBytes : null;\n  });\n  let unsub = noop;\n  function upload(newData, newMetadata) {\n    const storageSource = toValue(storageRef);\n    const currentTask = toValue(uploadTask);\n    if (currentTask) {\n      currentTask.cancel();\n    }\n    uploadError.value = null;\n    snapshot.value = null;\n    uploadTask.value = null;\n    url.value = null;\n    metadata.value = null;\n    unsub();\n    if (storageSource) {\n      const newTask = uploadBytesResumable(storageSource, newData, newMetadata);\n      uploadTask.value = newTask;\n      snapshot.value = newTask.snapshot;\n      unsub = newTask.on(\"state_changed\", (newSnapshot) => {\n        snapshot.value = newSnapshot;\n      });\n      return newTask.then((finalSnapshot) => {\n        metadata.value = finalSnapshot.metadata;\n        refreshUrl();\n      }).catch((err) => {\n        uploadError.value = err;\n        return Promise.reject(err);\n      }).finally(() => {\n        unsub();\n        uploadTask.value = null;\n      });\n    }\n  }\n  function refresh() {\n    return Promise.all([refreshUrl(), refreshMetadata()]);\n  }\n  if (isRef(storageRef) || typeof storageRef === \"function\") {\n    watch(storageRef, (storageSource) => {\n      if (!storageSource) {\n        if (uploadTask.value) {\n          unsub();\n          uploadTask.value.cancel();\n        }\n        uploadTask.value = null;\n        snapshot.value = null;\n      }\n      refresh();\n    });\n  }\n  if (getCurrentScope()) {\n    onScopeDispose(unsub);\n  }\n  return {\n    url,\n    metadata,\n    snapshot,\n    uploadTask,\n    uploadError,\n    uploadProgress,\n    upload,\n    updateMetadata: updateMetadata2,\n    refresh\n    // promise,\n  };\n}\nconst useStorage = useFirebaseStorage;\nconst useStorageUrl = useStorageFileUrl;\nconst useStorageMetadata = useStorageFileMetadata;\nconst useStorageObject = useStorageFile;\n\nfunction VueFire(app, { firebaseApp, modules = [] }) {\n  app.provide(_FirebaseAppInjectionKey, firebaseApp);\n  for (const firebaseModule of modules) {\n    firebaseModule(firebaseApp, app);\n  }\n}\n\nexport { VueFire, VueFireAuth, VueFireAuthOptionsFromAuth, VueFireAuthWithDependencies, VueFireDatabaseOptionsAPI, VueFireFirestoreOptionsAPI, _VueFireAuthInit, _VueFireAuthKey, createRecordFromDatabaseSnapshot as databaseDefaultSerializer, databasePlugin, devalueCustomParsers, devalueCustomStringifiers, firestoreDefaultConverter, firestorePlugin, DEFAULT_OPTIONS$1 as globalDatabaseOptions, DEFAULT_OPTIONS as globalFirestoreOptions, databasePlugin as rtdbPlugin, useCollection, useDatabase, useDatabaseList, useDatabaseObject, useDocument, useFirebaseApp, useFirebaseAuth, useFirebaseStorage, useFirestore, useList, useObject, usePendingPromises, useSSRInitialState, useStorage, useStorageFile, useStorageFileMetadata, useStorageFileUrl, useStorageMetadata, useStorageObject, useStorageUrl };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}